import com.mschematic.logging.Log;
import com.mschematic.logging.LogFactory;
import com.mschematic.rest.RestConnection;
import com.mschematic.rest.RestRequest;
import com.mschematic.rest.json.JSONContext;
import com.mschematic.service.ServiceException;
import com.mschematic.service.cache.CacheService;
import com.mschematic.svcfactory.ServiceFactory;
import com.mschematic.tsys.adapter.TSYSConstants;
import com.mschematic.tsys.adapter.model.Pair;
import com.mschematic.tsys.adapter.model.Token;
import com.mschematic.util.Messages;
import org.apache.commons.lang3.StringUtils;

import javax.annotation.Resource;
import javax.xml.bind.JAXBException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.Proxy;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.text.MessageFormat;
import java.util.Base64;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class TokenGeneratorAdapter implements TSYSConstants {
    private static final long THRESHOLD_MILLIS = 60000; // One minute threshold

    private static final Log log = LogFactory.getLog(TokenGeneratorAdapter.class);
    private static final Messages messages = Messages.getMessages(TokenGeneratorAdapter.class);
    @Resource
    protected ServiceFactory factory = null;
    private String system;
    private boolean isTraceEnabled;
    private boolean isFailOnUnknownProperties;
    private String defaultConnectionTimeOut;
    private String defaultReadTimeOut;
    private String grantType;
    private String apiScope;
    private String hostUrl;
    private boolean ignoreTrustCert;
    private boolean enableCertSecurity;
    private String clientId;
    private String clientSecret;
    private String keyStore;
    private String keyStorePwd;
    private String trustStore;
    private String trustStorePwd;
    private Proxy proxy;

    public TokenGeneratorAdapter(Proxy proxy) {

    }

    public Token getToken(String tokenName) {
        Token token = null;
        try {
            CacheService tokenCacheService = factory.getService(CacheService.class);
            //getTokenRealTime(baseUrl,tokenUri,formDataTemplate);
            if (token == null || token.isThresholdLimitReached()) {
                // Implement this method to fetch token from the server
            }
            cacheToken(tokenName, token);
        } catch (ServiceException serviceException) {

        }
        return token;
    }

    private void cacheToken(String cacheKey, Token newToken) throws ServiceException {
        CacheService cacheSvc = factory.getService(CacheService.class);
        if (newToken != null && cacheSvc != null) {
            cacheSvc.put("ehcache:" + cacheKey, cacheKey, newToken);
            log.info(GET_TOKEN, "Token Caching Complete : ");
        }
    }

    private <T> T getTokenRealTime(String baseUrl, String tokenUri, String formDataTemplate, List<String> formData, List<Pair> localVarQueryParams, String clientId, String clientSecret) throws ServiceException, IOException, JAXBException, GeneralSecurityException {

        log.begin(TSYSConstants.GET_TOKEN);

        Object result = null;
        RestConnection connection = null;
        String endpointURI = buildUrl(baseUrl, tokenUri, localVarQueryParams);

        RestRequest rr = RestRequest.newRequest(endpointURI);
        rr.setProxy(this.proxy);
        // String formDataTemplate = "grant_type={0}&scope={1}";
        connection = rr.post(MessageFormat.format(formDataTemplate, formData.toArray(new String[formData.size()])));
        connection.setJsonProvider(JSONContext.GSON);

        connection.setContentType(RestConnection.Protocol.FORM_URLENCODED);
        // timeouts
        connection.setConnectTimeout(Integer.parseInt(this.defaultConnectionTimeOut));
        connection.setReadTimeout(Integer.parseInt(this.defaultReadTimeOut));

        connection.setFailOnUnknownProps(isFailOnUnknownProperties);
        connection.setTrace(isTraceEnabled);

        if (enableCertSecurity) {
            // keystore and truststore
            if (StringUtils.isNotBlank(keyStore) && StringUtils.isNotBlank(keyStorePwd)) {
                connection.setKeyStore(keyStore, keyStorePwd);
            }
            if (StringUtils.isNotBlank(trustStore) && StringUtils.isNotBlank(trustStorePwd)) {
                connection.setTrustStore(trustStore, trustStorePwd);
            }
            connection.setIgnoreCertTrust(ignoreTrustCert);
        }

        connection.setRequestHeader(
                AUTHORIZATION, String.format("Basic %s", Base64.getEncoder().encodeToString((clientId + ":" + clientSecret).getBytes())));

        Class<T> requestClazz = (Class<T>) Token.class;
        result = connection.getResult(requestClazz, null, null);

        if (result != null) {
            log.info(TSYS, GET_TOKEN, "Token generation is successfull");
        } else {
            String msg = messages.getString(TSYS_303);
            log.error(TSYS, GET_TOKEN, msg);
            throw new ServiceException(msg, 303);
        }

        log.end(GET_TOKEN);

        return requestClazz.cast(result);
    }

    protected final String buildUrl(String baseURL, String path, List<Pair> queryParams) {
        log.begin(BUILD_URL);
        final StringBuilder url = new StringBuilder();
        url.append(baseURL).append(path);

        if (queryParams != null && !queryParams.isEmpty()) {
            String prefix = path.contains(SPL_CHAR_QUESTION) ? SPL_CHAR_AND : SPL_CHAR_QUESTION;
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append(SPL_CHAR_AND);
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append(SPL_CHAR_EQUAL).append(encodeString(value, StandardCharsets.UTF_8.toString()));
                }
            }
        }
        log.end(BUILD_URL);
        return url.toString();
    }

    /**
     * Coverts parameter To String
     *
     * @param param param
     * @return String
     */
    private String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Encodes the string using UTF-8 encoding format and replaces
     * new encoded version of space '+' to '%20'.
     *
     * @param str string to be processed
     * @return processed string value
     */
    protected final String escapeString(String str) {

        if (str == null) {
            return null;
        }

        String encodedString = encodeString(str, StandardCharsets.UTF_8.toString());

        if (encodedString == null) {
            return null;
        }

        return encodedString.replaceAll("\\+", "%20");
    }

    /**
     * Should only be used to encode the string values based on provided encoding.
     * If supplied encoding is null, default UTF-8 encoding will be used.
     *
     * @param value    value to be encoded
     * @param encoding encoding format
     * @return encodedString
     */
    private final String encodeString(String value, String encoding) {
        if (Objects.isNull(value)) {
            return null;
        }

        try {
            return URLEncoder.encode(value, Optional.ofNullable(encoding).orElse(StandardCharsets.UTF_8.toString()));
        } catch (UnsupportedEncodingException e) {
            log.error(this.system, ENCODE_STRING, e.getCause());
        }
        return null;
    }

    private void setKeyStore(String keyStore, String keyStorePwd) {
        this.keyStore = keyStore;
        this.keyStorePwd = keyStorePwd;
    }

    private void setTrustStore(String trustStore, String trustStorePwd) {
        this.trustStore = trustStore;
        this.trustStorePwd = trustStorePwd;
    }
}
