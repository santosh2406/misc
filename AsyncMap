package com.mschematic.tsys.adapter;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.mschematic.common.entity.RequestOptions;
import com.mschematic.common.service.SystemOfRecord;
import com.mschematic.common.util.IFXUtility;
import com.mschematic.ifxforum.AdditionalStatusType;
import com.mschematic.ifxforum.SeverityType;
import com.mschematic.ifxforum.StatusType;
import com.mschematic.logging.Log;
import com.mschematic.logging.LogFactory;
import com.mschematic.platform.reference.entity.Code;
import com.mschematic.platform.reference.entity.CodeCategory;
import com.mschematic.platform.services.Reference;
import com.mschematic.rest.RestConnection;
import com.mschematic.rest.RestConnectionException;
import com.mschematic.rest.RestRequest;
import com.mschematic.rest.json.JSONContext;
import com.mschematic.security.ExternalPropertiesFactory;
import com.mschematic.security.SecurityContext;
import com.mschematic.service.ServiceException;
import com.mschematic.service.ServiceSupport;
import com.mschematic.service.StatusDetail;
import com.mschematic.service.cache.CacheService;
import com.mschematic.svcfactory.ServiceFactory;
import com.mschematic.tsys.adapter.model.Pair;
import com.mschematic.tsys.adapter.util.TSYSUtil;
import com.mschematic.tsys.token.adapter.ClientCredential;
import com.mschematic.tsys.token.adapter.TokenGenerator;
import com.mschematic.util.Messages;
import com.mschematic.util.Properties;
import javapns.org.json.JSONArray;
import javapns.org.json.JSONObject;
import model.tsys.Error;
import model.tsys.ErrorErrors;
import org.apache.commons.lang3.StringUtils;

import javax.annotation.Resource;
import javax.xml.bind.JAXBException;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.InvocationTargetException;
import java.net.Authenticator;
import java.net.InetSocketAddress;
import java.net.PasswordAuthentication;
import java.net.Proxy;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;

/**
 * Abstract level code required for TSYS adapter classes.
 */
public abstract class AbstractTSYSAdapter extends ServiceSupport implements TSYSConstants {

    private static Messages messages = Messages.getMessages(AbstractTSYSAdapter.class);
    private static final Log log = LogFactory.getLog(AbstractTSYSAdapter.class);


    @Resource
    private SecurityContext securityContext = null;

    @Resource
    protected ServiceFactory factory = null;
    protected IFXUtility utility = new IFXUtility();
    private static final Object tokenLock = new Object();
    private ExternalPropertiesFactory externalPropertiesFactory = null;
    private String propertyFile = null;

    protected String defaultConnectionTimeOut = "60000";
    protected String defaultReadTimeOut = "60000";
    protected Properties properties = null;
    protected TokenGenerator tokenGenerator = null;

    /*
     * (non-Javadoc)
     *
     * @see com.mschematic.service.ServiceSupport#getSecurityContext()
     */
    @Override
    protected SecurityContext getSecurityContext() {
        SecurityContext.reset(null);
        return SecurityContext.getSecurityContext();

    }

    /**
     * propertyFile Setter
     *
     * @param propertyFile the propertyFile to set
     */
    public void setPropertyFile(String propertyFile) {
        this.propertyFile = propertyFile;
    }

    /**
     * propertyFile Getter
     *
     * @return Answers propertyFile
     */
    public String getPropertyFile() {
        return propertyFile;
    }

    /**
     * externalPropertiesFactory Getter
     *
     * @return Answers externalPropertiesFactory
     */
    public ExternalPropertiesFactory getExternalPropertiesFactory() {
        return externalPropertiesFactory;
    }

    /**
     * externalPropertiesFactory Setter
     *
     * @param externalPropertiesFactory the externalPropertiesFactory to set
     */
    public void setExternalPropertiesFactory(ExternalPropertiesFactory externalPropertiesFactory) {
        this.externalPropertiesFactory = externalPropertiesFactory;
    }


    /**
     * loadProperties
     */
    protected Properties loadProperties() throws ServiceException {

        log.begin(LOAD_PROPERTIES);

        if (this.propertyFile != null) {
            if (this.externalPropertiesFactory == null) {
                this.externalPropertiesFactory = new ExternalPropertiesFactory();
                log.error(TSYS, LOAD_PROPERTIES, "ExternalPropertiesFactory not initialized");
            }
            this.properties = this.externalPropertiesFactory.getProperties(this.propertyFile);
            if (this.properties == null) {
                log.error(TSYS, LOAD_PROPERTIES,
                        "External Properties file " + this.propertyFile + " not found");
                return null;
            }

            initRestConnectorProperties();
            ObjectMapper objectMapper = new ObjectMapper();
            objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
            objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);

        }
        log.end(LOAD_PROPERTIES);
        return properties;
    }

    /**
     * Process Exception with supplied params and prepares {@link StatusType} object as response.
     * <p>
     * This method scope is reduced to <b>private</b>, use the following methods
     * {@link #processAndThrowServiceException(Exception, String, Class, Log, Consumer, Consumer, Consumer, Consumer)}
     * {@link #processException(Exception, String, Class, Log, StatusType, Consumer, Consumer, Consumer, Consumer)}
     * <p>
     * If you don't supply {@link StatusType} object, it will create a new status object for processing.
     *
     * @param ex                    occurred exception
     * @param methodName            method name to log
     * @param adapterClass          adapter class to log
     * @param suppliedLogger        logger used to log messages
     * @param suppliedStatus        supply {@link StatusType} object to build the status,
     * @param restExceptionLogic    rest exception processing logic called after build status
     * @param ioExceptionLogic      io exception processing logic called after build status
     * @param serviceExceptionLogic service exception processing logic called after build status
     * @param genericExceptionLogic generic exception processing logic called after build status
     * @return {@link StatusType} object
     */
    private StatusType processExceptionWithParams(Exception ex,
                                                  String methodName,
                                                  Class<?> adapterClass,
                                                  Log suppliedLogger,
                                                  StatusType suppliedStatus,
                                                  Consumer<StatusType> restExceptionLogic,
                                                  Consumer<StatusType> ioExceptionLogic,
                                                  Consumer<StatusType> serviceExceptionLogic,
                                                  Consumer<StatusType> genericExceptionLogic) {

        log.begin(PROCESS_EXCEPTION);

        StatusType status = Optional.ofNullable(suppliedStatus).orElse(new StatusType());

        if (ex == null || adapterClass == null || StringUtils.isEmpty(methodName)) {
            log.debug(TSYS, PROCESS_EXCEPTION, "exception or adapterClass or methodName is null, exiting the processing logic.");
        } else {
            // use suppliedLogger to log the error at the caller/origination level
            Log logger = Optional.ofNullable(suppliedLogger).orElse(log);

            if (ex instanceof RestConnectionException) {
                RestConnectionException re = (RestConnectionException) ex;
                Integer code = Optional.ofNullable(re.getCode()).orElse(HTTP_500);
                buildStatus(adapterClass.getSimpleName(), status, re, null, null);
                logger.error(TSYS, methodName, String.format("%s-%s", String.valueOf(code), status.getStatusDesc()), re);
                Optional.ofNullable(restExceptionLogic).ifPresent(c -> c.accept(status));
            } else if ((ex instanceof GeneralSecurityException) || (ex instanceof IOException)) {
                String errorMessage = messages.getString(TSYS_300, ex.toString());
                logger.error(TSYS, methodName, errorMessage, ex);
                buildStatus(adapterClass.getSimpleName(), status, ex, ERROR_CODE_300, errorMessage);
                Optional.ofNullable(ioExceptionLogic).ifPresent(c -> c.accept(status));
            } else if (ex instanceof ServiceException) {
                ServiceException se = (ServiceException) ex;
                String errorMessage = messages.getString(TSYS_100, se.toString());
                logger.error(TSYS, methodName, errorMessage, se);
                buildStatus(adapterClass.getSimpleName(), status, se, ERROR_CODE_100, errorMessage);
                Optional.ofNullable(serviceExceptionLogic).ifPresent(c -> c.accept(status));
            } else {
                String errorMessage = messages.getString(TSYS_500, ex.toString());
                logger.error(TSYS, methodName, errorMessage, ex);
                buildStatus(adapterClass.getSimpleName(), status, ex, ERROR_CODE_500, errorMessage);
                Optional.ofNullable(genericExceptionLogic).ifPresent(c -> c.accept(status));
            }
        }

        log.end(PROCESS_EXCEPTION);

        return status;
    }

    /**
     * Process Exception with supplied params, builds status and throws {@link ServiceException}.
     *
     * @param ex                    occurred exception
     * @param methodName            method name to log
     * @param adapterClass          adapter class to log
     * @param suppliedLogger        logger used to log messages
     * @param restExceptionLogic    rest exception processing logic called after build status
     * @param ioExceptionLogic      io exception processing logic called after build status
     * @param serviceExceptionLogic service exception processing logic called after build status
     * @param genericExceptionLogic generic exception processing logic called after build status
     */
    protected void processAndThrowServiceException(Exception ex,
                                                   String methodName,
                                                   Class adapterClass,
                                                   Log suppliedLogger,
                                                   Consumer<StatusType> restExceptionLogic,
                                                   Consumer<StatusType> ioExceptionLogic,
                                                   Consumer<StatusType> serviceExceptionLogic,
                                                   Consumer<StatusType> genericExceptionLogic) throws ServiceException {

        StatusType status = processExceptionWithParams(ex, methodName, adapterClass, suppliedLogger, null, restExceptionLogic,
                ioExceptionLogic, serviceExceptionLogic, genericExceptionLogic);

        if (ex instanceof ServiceException) {
            throw (ServiceException) ex;
        } else {
            throw new ServiceException(status.getStatusDesc(), status.getStatusCode(), prepareStatusDetails(status), ex);
        }
    }

    /**
     * Process Exception with supplied params, builds status and throws {@link ServiceException}.
     *
     * @param ex             occurred exception
     * @param methodName     method name to log
     * @param adapterClass   adapter class to log
     * @param suppliedLogger logger used to log messages
     */
    protected void processAndThrowServiceException(Exception ex,
                                                   String methodName,
                                                   Class<?> adapterClass,
                                                   Log suppliedLogger) throws ServiceException {

        processAndThrowServiceException(ex, methodName, adapterClass, suppliedLogger, null, null, null, null);
    }

    /**
     * Process Exception with supplied params and prepares {@link StatusType} object as response.
     * <p>
     * If you don't supply {@link StatusType} object, it will create a new status object for processing.
     *
     * @param ex                    occurred exception
     * @param methodName            method name to log
     * @param adapterClass          adapter class to log
     * @param suppliedLogger        logger used to log messages
     * @param suppliedStatus        supply {@link StatusType} object to build the status,
     * @param restExceptionLogic    rest exception processing logic called after build status
     * @param ioExceptionLogic      io exception processing logic called after build status
     * @param serviceExceptionLogic service exception processing logic called after build status
     * @param genericExceptionLogic generic exception processing logic called after build status
     * @return {@link StatusType} object
     */
    protected StatusType processException(Exception ex,
                                          String methodName,
                                          Class<?> adapterClass,
                                          Log suppliedLogger,
                                          StatusType suppliedStatus,
                                          Consumer<StatusType> restExceptionLogic,
                                          Consumer<StatusType> ioExceptionLogic,
                                          Consumer<StatusType> serviceExceptionLogic,
                                          Consumer<StatusType> genericExceptionLogic) {

        return processExceptionWithParams(ex, methodName, adapterClass, suppliedLogger, suppliedStatus, restExceptionLogic,
                ioExceptionLogic, serviceExceptionLogic, genericExceptionLogic);
    }

    /**
     * Process Exception with supplied params and prepares {@link StatusType} object as response.
     * <p>
     * If you don't supply {@link StatusType} object, it will create a new status object for processing.
     *
     * @param ex             occurred exception
     * @param methodName     method name to log
     * @param adapterClass   adapter class to log
     * @param suppliedLogger logger used to log messages
     * @param suppliedStatus supply {@link StatusType} object to build the status,
     * @return {@link StatusType} object
     */
    protected StatusType processException(Exception ex,
                                          String methodName,
                                          Class<?> adapterClass,
                                          Log suppliedLogger,
                                          StatusType suppliedStatus) {

        return processException(ex, methodName, adapterClass, suppliedLogger, suppliedStatus, null, null, null, null);
    }

    /**
     * Constructs {@link StatusDetail} collection from {@link StatusType}.
     *
     * @param status status type
     * @return Collection of StatusDetail objects.
     */
    protected final List<StatusDetail> prepareStatusDetails(StatusType status) {

        List<StatusDetail> statusDetails = new ArrayList<>();

        if (Objects.nonNull(status) && Objects.nonNull(status.getAdditionalStatus())) {
            status.getAdditionalStatus().forEach((AdditionalStatusType additionalStatus) -> {
                // skip to next iteration
                if (Objects.isNull(additionalStatus)) {
                    return;
                }

                statusDetails.add(new StatusDetail(
                        String.valueOf(Optional.ofNullable(additionalStatus.getStatusCode()).orElse((long) HTTP_500)),
                        additionalStatus.getStatusDesc(),
                        Optional.ofNullable(additionalStatus.getSeverity()).orElse(SeverityType.ERROR).name(),
                        additionalStatus.getSource()
                ));
            });
        }

        return statusDetails;
    }

    /**
     * Builds status from an {@link Exception} and its sub-types.
     *
     * @param svcName                  ServiceName
     * @param suppliedStatus           status object to set the exception details
     * @param ex                       exception
     * @param suppliedErrorCode        error code supplied
     * @param suppliedErrorDescription error description supplied
     * @return Constructed StatusType object
     */
    protected final StatusType buildStatus(String svcName, StatusType suppliedStatus, Exception ex, String suppliedErrorCode, String suppliedErrorDescription) {
        log.begin(BUILD_STATUS + ":" + svcName);

        StatusType status = Optional.ofNullable(suppliedStatus).orElse(new StatusType());

        if (ex instanceof RestConnectionException) {
            return buildStatus(svcName, status, (RestConnectionException) ex);
        } else {
            if (StringUtils.isNumeric(suppliedErrorCode)) {
                status.setStatusCode(Long.parseLong(suppliedErrorCode));
            } else {
                suppliedErrorCode = ERROR_CODE_500;
                status.setStatusCode(Long.parseLong(suppliedErrorCode));
            }

            status.setServerStatusCode(suppliedErrorCode);

            status.setSeverity(SeverityType.ERROR);
            status.setStatusDesc(suppliedErrorDescription);

            status.getAdditionalStatus().add(populateAdditionalStatus(Long.parseLong(suppliedErrorCode), suppliedErrorDescription, SeverityType.ERROR, suppliedErrorCode));
        }
        log.end(BUILD_STATUS + ":" + svcName);
        return status;
    }

    /**
     * Builds status from an {@link RestConnectionException}.
     *
     * @param svcName        ServiceName
     * @param suppliedStatus status object to set the exception details
     * @param restConEx      Rest Connection Exception
     * @return Constructed StatusType object
     */
    protected final StatusType buildStatus(String svcName, StatusType suppliedStatus, RestConnectionException restConEx) {
        log.begin(BUILD_STATUS + ":" + svcName);

        StatusType status = Optional.ofNullable(suppliedStatus).orElse(new StatusType());

        String srvErrCd = null;
        // defaulting it to 500
        Integer errCd = 500;
        String errMsg = null;
        Error error = null;
        try {
            if (restConEx.getCode() != null) {
                errCd = restConEx.getCode();
            }
            if (StringUtils.isNotBlank(restConEx.getExtendedMessage()) || restConEx.getCause() != null) {
                try {
                    error = new Gson().fromJson(restConEx.getExtendedMessage(), Error.class);
                } catch (JsonSyntaxException jse) {
                    log.error(TSYS, BUILD_STATUS, jse.getMessage());
                }
                if (error != null) {
                    errMsg = error.getDetail();
                    if (error.getStatus() != null) {
                        srvErrCd = error.getStatus().toString();
                    }
                } else {
                    errMsg = processExtendedMessage(restConEx.getExtendedMessage(), ERROR_DESCRIPTION);
                    srvErrCd = StringUtils.defaultString(processExtendedMessage(restConEx.getExtendedMessage(), ERROR_CODE)).trim()
                            .replaceAll(DIGIT_REGEX, EMPTY_STRING);
                }
            }

            String statusDesc = restConEx.getLocalizedMessage();
            SeverityType severityType = SeverityType.ERROR;

            if (errCd.compareTo(HTTP_404) == 0) {
                statusDesc = SUCCESS;
                errCd = 0;
                severityType = SeverityType.INFO;
            } else if (errCd.compareTo(HTTP_408) == 0 || errCd.compareTo(HTTP_504) == 0) {
                errMsg = messages.getString(TSYS_300, restConEx.getLocalizedMessage());
                errCd = 300;
            }
            status.setSeverity(severityType);
            status.setStatusDesc(statusDesc);
            status.setStatusCode(errCd);
            status.setServerStatusCode(srvErrCd);
            status.getAdditionalStatus().add(populateAdditionalStatus(errCd, (errMsg != null ? errMsg : restConEx.getLocalizedMessage()), SeverityType.ERROR, srvErrCd));

            log.error(svcName + ": buildStatus -> [" + errCd + "]:" + errMsg);
        } catch (Exception exe) {
            status.setSeverity(SeverityType.ERROR);
            status.setStatusDesc(exe.getLocalizedMessage());
            status.setStatusCode(500L);
            log.error(TSYS, BUILD_STATUS, exe);
        }
        log.end(BUILD_STATUS + ":" + svcName);
        return status;
    }

    /**
     * processes Extended Message
     *
     * @param errDes error description
     * @param type   type
     * @return String
     */
    private String processExtendedMessage(String errDes, String type) {
        log.begin(PROCESS_EXT_MESSAGE);
        StringBuilder msg = new StringBuilder();
        try {
            if (errDes != null && errDes.contains(ERROR_CODE)) {
                JSONObject obj = new JSONObject(errDes).getJSONObject(PAYLOAD).getJSONObject(OUTPUT_HEADER);
                JSONArray array = obj.getJSONArray(ERROR_LST);
                if (array != null) {
                    int length = array.length();
                    String text = "";
                    JSONObject json = null;
                    for (int i = 0; i < length; i++) {
                        json = (JSONObject) array.get(i);
                        if (json != null) {
                            if (msg.length() > 0) {
                                msg.append(DELIMITER_PIPE);
                            }
                            if (ERROR_CODE.equals(type) && !"-1".equalsIgnoreCase(json.getString(ERROR_CODE)) && "".equals(text)) {
                                text = json.getString(ERROR_CODE);
                                msg.append(text);
                                break;
                            } else if (!NULL.equalsIgnoreCase(json.getString(ERROR_DESCRIPTION))) {
                                text = json.getString(ERROR_DESCRIPTION);
                                msg.append(text);
                            }
                        }
                    }
                }
            }
        } catch (Exception e) {
            try {
                String text = "";
                JSONObject json = (JSONObject) new JSONObject(errDes).get("fault");
                ;
                if (json != null) {
                    if (msg.length() > 0) {
                        msg.append(DELIMITER_PIPE);
                    }
                    if (LOWERCASE_CODE.equalsIgnoreCase(type) && !"-1".equalsIgnoreCase(json.getString(LOWERCASE_CODE)) && text.equals("")) {
                        text = json.getString(LOWERCASE_CODE);
                        msg.append(text);

                    } else if (ERROR_DESCRIPTION.equalsIgnoreCase(type) && !NULL.equalsIgnoreCase(json.getString(DESC))) {
                        text = json.getString(DESC);
                        msg.append(text);
                    }
                }
            } catch (Exception exception) {
                log.warn(PROCESS_EXT_MESSAGE, "error while processing RestException message - " + exception.getMessage());
            }
            log.warn(PROCESS_EXT_MESSAGE, "error while processing RestException message - " + e.getMessage());
        }

        log.end(PROCESS_EXT_MESSAGE);
        return msg.toString();
    }

    /**
     * @param errorCode
     * @param message
     * @param severity
     * @return
     */
    protected AdditionalStatusType populateAdditionalStatus(long errorCode, String message, SeverityType severity, String severStatusCd) {
        AdditionalStatusType additionalStatus = new AdditionalStatusType();
        if (severStatusCd != null)
            additionalStatus.setServerStatusCode(severStatusCd);
        else
            additionalStatus.setServerStatusCode(String.valueOf(errorCode));
        additionalStatus.setStatusCode(Long.valueOf(errorCode));
        additionalStatus.setSeverity(severity);
        additionalStatus.setStatusDesc(message);
        additionalStatus.setSource(TSYS);

        return additionalStatus;
    }

    /**
     * Performs the REST call with specified endpoint details with token in cache.
     *
     * @param endpointURI                   endpointURI
     * @param respObj                       respObj
     * @param request                       request
     * @param method                        method
     * @param connectionTimeOut             connectionTimeOut
     * @param readTimeOut                   readTimeOut
     * @param maskFields                    maskFields
     * @param safeCatchRestExceptionLogName safeCatchRestExceptionLogName
     * @param <T>                           T
     * @return T
     * @throws ServiceException         exception including all details about service interruption
     * @throws GeneralSecurityException General Security Exception
     * @throws JAXBException            includes details about xml parsing failure
     * @throws IOException              includes details about IO failure
     */
    protected <T> T transmit(String endpointURI, Class<T> respObj, Object request, String method, String connectionTimeOut, String readTimeOut, String maskFields, String safeCatchRestExceptionLogName, Consumer<Map<String, List<String>>> responseHeaderConsumer)
            throws IOException, JAXBException, GeneralSecurityException, ServiceException {

        try {
            return transmit(endpointURI, respObj, request, method, connectionTimeOut, readTimeOut, maskFields, safeCatchRestExceptionLogName, null, false);
        } catch (RestConnectionException ex) {
            if (Integer.valueOf(401).equals(ex.getCode())) {

                return transmit(endpointURI, respObj, request, method, connectionTimeOut, readTimeOut, maskFields, safeCatchRestExceptionLogName, null, true);
            }
            throw ex;
        }
    }

    /**
     * Performs the REST call with specified endpoint details.
     *
     * @param endpointURI                   endpointURI
     * @param respObj                       respObj
     * @param request                       request
     * @param method                        method
     * @param connectionTimeOut             connectionTimeOut
     * @param readTimeOut                   readTimeOut
     * @param maskFields                    maskFields
     * @param safeCatchRestExceptionLogName safeCatchRestExceptionLogName
     * @param <T>                           T
     * @return T
     * @throws ServiceException         exception including all details about service interruption
     * @throws GeneralSecurityException General Security Exception
     * @throws JAXBException            includes details about xml parsing failure
     * @throws IOException              includes details about IO failure
     */
    protected final <T> T transmit(String endpointURI, Class<T> respObj, Object request, String method, String connectionTimeOut, String readTimeOut, String maskFields, String safeCatchRestExceptionLogName, Consumer<Map<String, List<String>>> responseHeaderConsumer, boolean reload)
            throws IOException, JAXBException, GeneralSecurityException, ServiceException {

        log.begin(TRANSMIT);
        Map<String, String> headers = new HashMap<>();
        initRestConnectorProperties();
        headers.put(AUTHORIZATION, String.join(" ", BEARER_TOKEN_PREFIX, tokenGenerator.getToken("").getAccess_token()));

        Object result = null;
        RestConnection connection;
        RestRequest rr = RestRequest.newRequest(endpointURI);
        //Set Proxy
        rr.setProxy(getProxy());

        if (POST.equals(method))
            connection = rr.post(request);
        else if (GET.equals(method))
            connection = rr.get();
        else if (PUT.equals(method))
            connection = rr.put(request);
        else if (DELETE.equals(method))
            connection = rr.delete(request);
        else
            connection = rr.get();

        Boolean secureLog = Boolean.valueOf(TSYSUtil.safeGetProperty(this.properties, IS_SECURE_LOG, "true"));
        connection.setSecureLog(secureLog);

        connection.setAccepts(RestConnection.Protocol.JSON);
        connection.setContentType(RestConnection.Protocol.JSON);
        connection.setJsonProvider(JSONContext.GSON);

        // enable log data
        boolean isTraceEnabled = Boolean.parseBoolean(TSYSUtil.safeGetProperty(this.properties, TSYS_ISENABLE_TRACE, "true"));
        connection.setTrace(isTraceEnabled);

        // set timeouts
        connection.setConnectTimeout(Integer.parseInt(Optional.ofNullable(connectionTimeOut).orElse(this.defaultConnectionTimeOut)));
        connection.setReadTimeout(Integer.parseInt(Optional.ofNullable(readTimeOut).orElse(this.defaultReadTimeOut)));

        String enableCertSecurity = TSYSUtil.safeGetProperty(this.properties, TSYS_ENABLE_CERT_SECURITY, TRUE);
        if (StringUtils.equalsIgnoreCase(enableCertSecurity, TRUE)) {
            // keystore and truststore
            String keyStore = TSYSUtil.safeGetProperty(this.properties, TSYS_KEYSTORE);
            String keyStorePwd = TSYSUtil.safeGetProperty(this.properties, TSYS_KEYSTORE_PWD);
            String trustStore = TSYSUtil.safeGetProperty(this.properties, TSYS_TRUSTSTORE);
            String trustStorePwd = TSYSUtil.safeGetProperty(this.properties, TSYS_TRUSTSTORE_PWD);
            String ignoreTrustCert = TSYSUtil.safeGetProperty(this.properties, TSYS_IGNORE_TRUST_CERT);

            if (StringUtils.isNotBlank(keyStore)&& StringUtils.isNotBlank(keyStorePwd)) {
                connection.setKeyStore(keyStore, keyStorePwd);
            }

            if (StringUtils.isNotBlank(trustStore)&& StringUtils.isNotBlank(trustStorePwd)) {
                connection.setTrustStore(trustStore, trustStorePwd);
            }

            if (StringUtils.isNotBlank(ignoreTrustCert)) {
                connection.setIgnoreCertTrust(Boolean.valueOf(ignoreTrustCert));
            }
        }
        Boolean isFailOnUnknownProperties = Boolean.parseBoolean(TSYSUtil.safeGetProperty(this.properties, TSYS_IS_FAIL_ON_UNKNOWN_PROPERTIES, "true"));
        connection.setFailOnUnknownProps(isFailOnUnknownProperties);

        if (maskFields != null)
            connection.setMaskFields(maskFields);

        // set request headers on this connection
        headers.forEach((key, value) -> connection.setRequestHeader(key, value));

        try {
            if (byte[].class.equals(respObj)) {
                result = connection.getResultAsStream(null, null);
            } else {
                result = connection.getResult(respObj, null, null);
            }

            Optional.ofNullable(responseHeaderConsumer).ifPresent(c -> c.accept(connection.getResponseHeaders()));

        } catch (RestConnectionException ex) {
            if (Integer.valueOf(401).equals(ex.getCode()) && StringUtils.isNotEmpty(safeCatchRestExceptionLogName)) {
                log.error(TSYS, safeCatchRestExceptionLogName, messages.getString(TSYS_302, ex.toString()), ex);
            } else {
                throw ex;
            }
        }


        log.end(TRANSMIT);

        return respObj.cast(result);
    }

    private void initRestConnectorProperties() {
        String authorizeFormData = "grant_type={0}&scope={1}";
        tokenGenerator = new TokenGenerator(TSYSUtil.safeGetProperty(this.properties, TSYS_TOKEN_BASE_URL),TSYSUtil.safeGetProperty(this.properties, TSYS_TOKEN_URI));
        tokenGenerator.setFormDataTemplate(authorizeFormData);
        tokenGenerator.setThresholdPrcnt(10);
        tokenGenerator.setApiScope(TSYSUtil.safeGetProperty(this.properties, TSYS_TOKEN_SCOPE));
        tokenGenerator.setTraceEnabled(Boolean.valueOf(TSYSUtil.safeGetProperty(this.properties, TSYS_IS_FAIL_ON_UNKNOWN_PROPERTIES, "true")));
        tokenGenerator.setFailOnUnknownProperties(Boolean.valueOf(TSYSUtil.safeGetProperty(this.properties, TSYS_IS_FAIL_ON_UNKNOWN_PROPERTIES, "true")));
        tokenGenerator.setProxy(getProxy());
        tokenGenerator.setConnectionTimeOut(this.defaultConnectionTimeOut);
        tokenGenerator.setReadTimeOut(this.defaultReadTimeOut);
        tokenGenerator.setEnableCertSecurity(Boolean.valueOf(TSYSUtil.safeGetProperty(this.properties, TSYS_ENABLE_CERT_SECURITY, TRUE)));

        tokenGenerator.setKeyStore(TSYSUtil.safeGetProperty(this.properties, TSYS_KEYSTORE));
        tokenGenerator.setKeyStorePwd(TSYSUtil.safeGetProperty(this.properties, TSYS_KEYSTORE_PWD));
        tokenGenerator.setTrustStore(TSYSUtil.safeGetProperty(this.properties, TSYS_TRUSTSTORE));
        tokenGenerator.setTrustStorePwd(TSYSUtil.safeGetProperty(this.properties, TSYS_TRUSTSTORE_PWD));
        tokenGenerator.setIgnoreTrustCert(Boolean.valueOf(TSYSUtil.safeGetProperty(this.properties, TSYS_IGNORE_TRUST_CERT)));

        ClientCredential clientCredential = new ClientCredential(TSYSUtil.safeGetProperty(this.properties, TSYS_CLIENT_ID),TSYSUtil.safeGetProperty(this.properties, TSYS_CLIENT_SECRET));
        tokenGenerator.setClientAuthorization(clientCredential);

        List<String> formData = new ArrayList<>();
        formData.add(TSYSUtil.safeGetProperty(this.properties, TSYS_TOKEN_GRANT_TYPE));
        formData.add(TSYSUtil.safeGetProperty(this.properties, TSYS_TOKEN_SCOPE));

        tokenGenerator.setFormData(formData);
    }

    /**
     * @return
     */
    private Proxy getProxy() {

        Proxy proxy = null;
        String proxyHost = TSYSUtil.safeGetProperty(this.properties, TSYS_PROXYHOST);
        String proxyUser = TSYSUtil.safeGetProperty(this.properties, TSYS_PROXYUSER);
        String proxyProtocol = TSYSUtil.safeGetProperty(this.properties, TSYS_PROXYPROTOCOL);
        String proxyPort = TSYSUtil.safeGetProperty(this.properties, TSYS_PROXYPORT);
        String proxyPassword = TSYSUtil.safeGetProperty(this.properties, TSYS_PROXYPWD);

        if (StringUtils.isNotBlank(proxyHost)) {
            Proxy.Type proxyType;
            if (StringUtils.isBlank(proxyProtocol)) {
                proxyType = Proxy.Type.HTTP;
            } else {
                proxyType = Proxy.Type.valueOf(proxyProtocol.toUpperCase());
            }

            proxy = new Proxy(proxyType, new InetSocketAddress(proxyHost, Integer.parseInt(proxyPort)));
        }

        if (StringUtils.isNotBlank(proxyUser) && StringUtils.isNotBlank(proxyPassword)) {
            Authenticator.setDefault(
                    new Authenticator() {
                        @Override
                        public PasswordAuthentication getPasswordAuthentication() {
                            return new PasswordAuthentication(
                                    proxyUser, proxyPassword.toCharArray()
                            );
                        }
                    }
            );
        }


        return proxy;
    }


    /**
     * Builds REST endpoint url.
     *
     * @param baseURL     Base URL
     * @param path        Path URL
     * @param queryParams Query Params
     * @return Constructed endpoint URL
     */
    protected final String buildUrl(String baseURL, String path, List<Pair> queryParams) {
        log.begin(BUILD_URL);
        final StringBuilder url = new StringBuilder();
        url.append(baseURL).append(path);

        if (queryParams != null && !queryParams.isEmpty()) {
            String prefix = path.contains(SPL_CHAR_QUESTION) ? SPL_CHAR_AND : SPL_CHAR_QUESTION;
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append(SPL_CHAR_AND);
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append(SPL_CHAR_EQUAL).append(encodeString(value, StandardCharsets.UTF_8.toString()));
                }
            }
        }
        log.end(BUILD_URL);
        return url.toString();
    }

    /**
     * Should only be used to encode the string values based on provided encoding.
     * If supplied encoding is null, default UTF-8 encoding will be used.
     *
     * @param value    value to be encoded
     * @param encoding encoding format
     * @return encodedString
     */
    private final String encodeString(String value, String encoding) {
        if (Objects.isNull(value)) {
            return null;
        }

        try {
            return URLEncoder.encode(value, Optional.ofNullable(encoding).orElse(StandardCharsets.UTF_8.toString()));
        } catch (UnsupportedEncodingException e) {
            log.error(TSYS, ENCODE_STRING, e.getCause());
        }
        return null;
    }

    /**
     * Encodes the string using UTF-8 encoding format and replaces
     * new encoded version of space '+' to '%20'.
     *
     * @param str string to be processed
     * @return processed string value
     */
    protected final String escapeString(String str) {

        if (str == null) {
            return null;
        }

        String encodedString = encodeString(str, StandardCharsets.UTF_8.toString());

        if (encodedString == null) {
            return null;
        }

        return encodedString.replaceAll("\\+", "%20");
    }

    /**
     * Coverts parameter To String
     *
     * @param param param
     * @return String
     */
    private String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Creates the object from the json file
     *
     * @param fileName fileName
     * @param type     object type
     * @param <T>      T
     * @return Object
     */
    protected final <T> T fromJson(String fileName, Class<T> type) {
        log.begin(FROM_JSON);
        T t = null;

        try (InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName);
             BufferedReader br = (Objects.nonNull(is) ? new BufferedReader(new InputStreamReader(is)) : null)) {

            if (br != null) {
                t = new Gson().fromJson(br, type);
            } else {
                log.error(TSYS, String.format("File not found %s", fileName));
            }
        } catch (Exception e) {
            log.error(TSYS, FROM_JSON, e);
        }

        log.end(FROM_JSON);
        return t;
    }

    /**
     * Returns Card Status Code Description based upon host card status code.
     * @param options Request option
     * @return  Map<String, List<Code>> Card Status sorted by statusCode as key
     */
    public Map<String, List<Code>> getCardStatusCode(RequestOptions options) {
        log.begin(GET_CARD_STATUS_CODE_DESC);
        Map<String, List<Code>> cardStatusCodesMap = null;
        try {
            CacheService cacheSvc = factory.getService(CacheService.class);
            Reference referenceSvc = factory.getService(Reference.class);
            if (cacheSvc == null) {
                log.error(TSYS, "Cache Service is null");
                return cardStatusCodesMap;
            }
            cardStatusCodesMap = (Map<String, List<Code>>) cacheSvc.get(EHCACHE_CARD_STATUS_CODES, CACHE_KEY_CARD_STATUS_CODE);

            if(cardStatusCodesMap == null || cardStatusCodesMap.size() == 0){
                if (referenceSvc == null) {
                    log.error(TSYS, "Reference Service is null");
                    return cardStatusCodesMap;
                }
                CodeCategory category = new CodeCategory();
                category.setName(CARD_STATUS_CODES);
                List<Code> codes= referenceSvc.getCodes(category, options.getLanguage(), com.mschematic.platform.common.entity.Status.Active, options);
                cardStatusCodesMap = new HashMap<>();
                for (Code c : codes){
                    if (c == null || c.getName() == null || c.getValue() == null || c.getCodeOrder() == null) continue;
                    String statusCode = c.getName().split(COLON)[0];
                    List<Code> temp = null;
                    if (cardStatusCodesMap.size() == 0) {
                        temp = new ArrayList<>();
                        cardStatusCodesMap.put(statusCode, temp);
                    } else {
                        temp = cardStatusCodesMap.computeIfAbsent(statusCode, k -> new ArrayList<>());
                    }
                    temp.add(c);

                }
                cacheSvc.put(EHCACHE_CARD_STATUS_CODES, CACHE_KEY_CARD_STATUS_CODE, cardStatusCodesMap);
            }
        } catch (Exception ex) {
            log.error(SystemOfRecord.Database, ex);
        }
        log.end(GET_CARD_STATUS_CODE_DESC);

        return cardStatusCodesMap;
    }

    /**
     * Get additional status for Async service calls
     * @param exception
     * @return
     */
    protected AdditionalStatusType getAdditionalStatusAsyncCall(Class<?> adapterClass,Exception exception) {
        if(exception.getCause() instanceof ServiceException){
            ServiceException serviceException = (ServiceException) exception.getCause();
            if(serviceException.getCause() instanceof InvocationTargetException){
                InvocationTargetException ite = (InvocationTargetException)serviceException.getCause();
                if(ite.getTargetException() instanceof  ServiceException){
                    ServiceException serviceExcep = (ServiceException)ite.getTargetException();
                    if(serviceExcep.getCause() instanceof RestConnectionException){
                        RestConnectionException restConnectionException = (RestConnectionException)serviceExcep.getCause();
                        return buildAdditionalStatus(adapterClass.getSimpleName(), restConnectionException);
                    }
                }
            }
        }
        return null;
    }

    protected final AdditionalStatusType buildAdditionalStatus(String svcName,RestConnectionException restConnectionException) {
        log.begin(BUILD_STATUS + ":" + svcName);

        AdditionalStatusType additionalStatusType = null;

        String srvErrCd = null;
        // defaulting it to 500
        Integer errCd = 500;
        StringBuilder errMsg = new StringBuilder();
        Error error = null;
        try {
            if (restConnectionException.getCode() != null) {
                errCd = restConnectionException.getCode();
            }
            {
                try {
                    error = new Gson().fromJson(restConnectionException.getExtendedMessage(), Error.class);
                } catch (JsonSyntaxException jse) {
                    log.error(TSYS, BUILD_STATUS, jse.getMessage());
                }
                if (error != null) {
                    if (error.getErrors() != null && error.getErrors().size() >0) {
                        int totalErrors = error.getErrors().size();
                        if(totalErrors ==1){
                            errMsg.append(error.getErrors().get(0));
                        }else if(totalErrors >1){
                            for (ErrorErrors code : error.getErrors()) {
                                errMsg.append(code.getMessage()).append(COMMA);
                            }
                            errMsg.deleteCharAt(errMsg.length()-1);
                        }
                    }else if(error.getDetail() != null){
                        errMsg.append(error.getDetail());
                    }
                } else {
                    errMsg.append(processExtendedMessage(restConnectionException.getExtendedMessage(), ERROR_DESCRIPTION));
                    srvErrCd = StringUtils.defaultString(processExtendedMessage(restConnectionException.getExtendedMessage(), ERROR_CODE)).trim()
                            .replaceAll(DIGIT_REGEX, EMPTY_STRING);
                }
            }

            additionalStatusType = populateAdditionalStatus(errCd, (errMsg != null ? errMsg.toString() : restConnectionException.getLocalizedMessage()), SeverityType.ERROR, srvErrCd);

            log.error(svcName + ": buildStatus -> [" + errCd + "]:" + errMsg);
        } catch (Exception exe) {
            additionalStatusType = new AdditionalStatusType();
            additionalStatusType.setSeverity(SeverityType.ERROR);
            additionalStatusType.setStatusDesc(exe.getLocalizedMessage());
            additionalStatusType.setStatusCode(500L);
            log.error(TSYS, BUILD_STATUS, exe);
        }
        log.end(BUILD_STATUS + ":" + svcName);
        return additionalStatusType;
    }


}
--------------------------------------------------------------------
package com.mschematic.tsys.token.adapter;

import com.mschematic.logging.Log;
import com.mschematic.logging.LogFactory;
import com.mschematic.rest.RestConnection;
import com.mschematic.rest.RestRequest;
import com.mschematic.rest.json.JSONContext;
import com.mschematic.service.ServiceException;
import com.mschematic.service.cache.CacheService;
import com.mschematic.svcfactory.ServiceFactory;
import com.mschematic.tsys.adapter.TSYSConstants;
import com.mschematic.tsys.adapter.model.Pair;
import com.mschematic.tsys.adapter.model.Token;
import com.mschematic.util.Messages;
import org.apache.commons.lang3.StringUtils;

import javax.annotation.Resource;
import javax.xml.bind.JAXBException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.Proxy;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.text.MessageFormat;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

public class TokenGenerator implements TSYSConstants {
    private static final long THRESHOLD_PERCNT_LVL = 100;

    private static final Log log = LogFactory.getLog(TokenGenerator.class);
    private static final Messages messages = Messages.getMessages(TokenGenerator.class);
    @Resource
    protected ServiceFactory factory = null;
    private String system;
    private boolean isTraceEnabled;
    private boolean isFailOnUnknownProperties;
    private String connectionTimeOut;
    private String readTimeOut;
    private String grantType;
    private String apiScope;
    private String hostUrl;
    private boolean ignoreTrustCert;
    private boolean enableCertSecurity;


    private String keyStore;
    private String keyStorePwd;
    private String trustStore;
    private String trustStorePwd;
    private Proxy proxy;
    private String baseUrl;
    private String tokenUri;
    private String formDataTemplate;
    private List<String> formData;


    private List<Pair> localVarQueryParams;
    private ClientCredential clientAuthorization;

    private  int thresholdPrcnt;

    public TokenGenerator(String baseUrl, String tokenUri) {
        this.setBaseUrl(baseUrl);
        this.setTokenUri(tokenUri);
    }

    public Token getToken(String tokenName) {
        Token token = null;
        try {
            token = getCachedToken(tokenName);
            if (token == null || token.isThresholdLimitReached()) {
                // Implement this method to fetch token from the server
                log.debug(GET_TOKEN, String.format("About to generate fresh token (reloadToken) : %s",getSystem()));
                token =getTokenFromServer(getFormDataTemplate(),getFormData());
                log.info(GET_TOKEN, String.format("New Token  generation Complete : %s",getSystem()));
            }
            cacheToken(tokenName, token);
            log.info(GET_TOKEN, String.format("Token  Caching Complete : %s",getSystem()));
        } catch (ServiceException serviceException) {
            log.debug(GET_TOKEN, "Failing to retrieve cached token due to:", serviceException);
            getToken(tokenName);
        }
        return token;
    }

    private Token getCachedToken(String cacheKey) throws ServiceException {
        CacheService cacheSvc = factory.getService(CacheService.class);
        Token cachedToken = null;
        if (cacheSvc != null) {
            cachedToken = (Token)cacheSvc.get("ehcache:" + cacheKey, Token.class);
            log.info(GET_TOKEN, "Token Caching Complete : ");
        }
        return cachedToken;
    }

    private void cacheToken(String cacheKey, Token newToken) throws ServiceException {
        CacheService cacheSvc = factory.getService(CacheService.class);
        if (newToken != null && cacheSvc != null) {
            cacheSvc.put("ehcache:" + cacheKey, cacheKey, newToken);
            log.info(GET_TOKEN, "Token Caching Complete : ");
        }
    }

    private Token getTokenFromServer(String formDataTemplate, List<String> formData) throws ServiceException {

        log.begin(TSYSConstants.GET_TOKEN);

        Token token = null;
        RestConnection connection = null;
        String endpointURI = buildUrl(this.getBaseUrl(), this.getTokenUri(), this.getLocalVarQueryParams());
        try{
            RestRequest rr = RestRequest.newRequest(endpointURI);
            rr.setProxy(this.getProxy());
            connection = rr.post(MessageFormat.format(formDataTemplate, formData.toArray(new String[formData.size()])));
            connection.setJsonProvider(JSONContext.GSON);
            connection.setContentType(RestConnection.Protocol.FORM_URLENCODED);
            connection.setConnectTimeout(Integer.parseInt(this.getConnectionTimeOut()));
            connection.setReadTimeout(Integer.parseInt(this.getReadTimeOut()));
            connection.setFailOnUnknownProps(isFailOnUnknownProperties());
            connection.setTrace(isTraceEnabled());
            if (isEnableCertSecurity()) {
                // keystore and truststore
                if (StringUtils.isNotBlank(getKeyStore()) && StringUtils.isNotBlank(getKeyStorePwd())) {
                    connection.setKeyStore(getKeyStore(), getKeyStorePwd());
                }
                if (StringUtils.isNotBlank(getTrustStore()) && StringUtils.isNotBlank(getTrustStorePwd())) {
                    connection.setTrustStore(getTrustStore(), getTrustStorePwd());
                }
                connection.setIgnoreCertTrust(isIgnoreTrustCert());
            }
            connection.setRequestHeader(
                    AUTHORIZATION, getClientAuthorization().getAuthorization());
            token = connection.getResult(Token.class, null, null);
            if (token != null) {
                if(thresholdPrcnt <0.0 || thresholdPrcnt >=100.0){
                    throw new ServiceException("Threshold percentage must be between 0 and 1");
                }
                long expitationTime = calcExpirationWithThreshold(token.getExpires_in(), thresholdPrcnt);
                token.setExpirationTime(expitationTime);
                log.info(TSYS, GET_TOKEN, "Token generation is successfull");
            } else {
                String msg = messages.getString(TSYS_303);
                log.error(TSYS, GET_TOKEN, msg);
                throw new ServiceException(msg, 303);
            }
        }catch(IOException|JAXBException|GeneralSecurityException exception){
            throw new ServiceException(exception);
        }

        log.end(GET_TOKEN);

        return token;
    }

    private long calcExpirationWithThreshold(long origExpirationTime, double thresholdPercentage){
        long thresholdInMilies = (long) (origExpirationTime *(thresholdPercentage/100.0));
        return origExpirationTime - thresholdInMilies;
    }
    protected final String buildUrl(String baseURL, String path, List<Pair> queryParams) {
        log.begin(BUILD_URL);
        final StringBuilder url = new StringBuilder();
        url.append(baseURL).append(path);

        if (queryParams != null && !queryParams.isEmpty()) {
            String prefix = path.contains(SPL_CHAR_QUESTION) ? SPL_CHAR_AND : SPL_CHAR_QUESTION;
            for (Pair param : queryParams) {
                if (param.getValue() != null) {
                    if (prefix != null) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append(SPL_CHAR_AND);
                    }
                    String value = parameterToString(param.getValue());
                    url.append(escapeString(param.getName())).append(SPL_CHAR_EQUAL).append(encodeString(value, StandardCharsets.UTF_8.toString()));
                }
            }
        }
        log.end(BUILD_URL);
        return url.toString();
    }

    /**
     * Coverts parameter To String
     *
     * @param param param
     * @return String
     */
    private String parameterToString(Object param) {
        if (param == null) {
            return "";
        } else if (param instanceof Collection) {
            StringBuilder b = new StringBuilder();
            for (Object o : (Collection) param) {
                if (b.length() > 0) {
                    b.append(",");
                }
                b.append(o);
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Encodes the string using UTF-8 encoding format and replaces
     * new encoded version of space '+' to '%20'.
     *
     * @param str string to be processed
     * @return processed string value
     */
    protected final String escapeString(String str) {

        if (str == null) {
            return null;
        }

        String encodedString = encodeString(str, StandardCharsets.UTF_8.toString());

        if (encodedString == null) {
            return null;
        }

        return encodedString.replaceAll("\\+", "%20");
    }

    /**
     * Should only be used to encode the string values based on provided encoding.
     * If supplied encoding is null, default UTF-8 encoding will be used.
     *
     * @param value    value to be encoded
     * @param encoding encoding format
     * @return encodedString
     */
    private final String encodeString(String value, String encoding) {
        if (Objects.isNull(value)) {
            return null;
        }

        try {
            return URLEncoder.encode(value, Optional.ofNullable(encoding).orElse(StandardCharsets.UTF_8.toString()));
        } catch (UnsupportedEncodingException e) {
            log.error(this.getSystem(), ENCODE_STRING, e.getCause());
        }
        return null;
    }

    private void setKeyStore(String keyStore, String keyStorePwd) {
        this.setKeyStore(keyStore);
        this.setKeyStorePwd(keyStorePwd);
    }

    private void setTrustStore(String trustStore, String trustStorePwd) {
        this.setTrustStore(trustStore);
        this.setTrustStorePwd(trustStorePwd);
    }

    /**
     * getSystem
     *
     * @return system
     */
    public String getSystem() {
        return system;
    }

    /**
     * Sets system
     *
     * @param system system to set
     */
    public void setSystem(String system) {
        this.system = system;
    }

    /**
     * getTraceEnabled
     *
     * @return isTraceEnabled
     */
    public boolean isTraceEnabled() {
        return isTraceEnabled;
    }

    /**
     * Sets isTraceEnabled
     *
     * @param traceEnabled isTraceEnabled to set
     */
    public void setTraceEnabled(boolean traceEnabled) {
        isTraceEnabled = traceEnabled;
    }

    /**
     * getFailOnUnknownProperties
     *
     * @return isFailOnUnknownProperties
     */
    public boolean isFailOnUnknownProperties() {
        return isFailOnUnknownProperties;
    }

    /**
     * Sets isFailOnUnknownProperties
     *
     * @param failOnUnknownProperties isFailOnUnknownProperties to set
     */
    public void setFailOnUnknownProperties(boolean failOnUnknownProperties) {
        isFailOnUnknownProperties = failOnUnknownProperties;
    }

    /**
     * getDefaultConnectionTimeOut
     *
     * @return defaultConnectionTimeOut
     */
    public String getConnectionTimeOut() {
        return connectionTimeOut;
    }

    /**
     * Sets defaultConnectionTimeOut
     *
     * @param connectionTimeOut defaultConnectionTimeOut to set
     */
    public void setConnectionTimeOut(String connectionTimeOut) {
        this.connectionTimeOut = connectionTimeOut;
    }

    /**
     * getDefaultReadTimeOut
     *
     * @return defaultReadTimeOut
     */
    public String getReadTimeOut() {
        return readTimeOut;
    }

    /**
     * Sets defaultReadTimeOut
     *
     * @param readTimeOut defaultReadTimeOut to set
     */
    public void setReadTimeOut(String readTimeOut) {
        this.readTimeOut = readTimeOut;
    }

    /**
     * getGrantType
     *
     * @return grantType
     */
    public String getGrantType() {
        return grantType;
    }

    /**
     * Sets grantType
     *
     * @param grantType grantType to set
     */
    public void setGrantType(String grantType) {
        this.grantType = grantType;
    }

    /**
     * getApiScope
     *
     * @return apiScope
     */
    public String getApiScope() {
        return apiScope;
    }

    /**
     * Sets apiScope
     *
     * @param apiScope apiScope to set
     */
    public void setApiScope(String apiScope) {
        this.apiScope = apiScope;
    }

    /**
     * getHostUrl
     *
     * @return hostUrl
     */
    public String getHostUrl() {
        return hostUrl;
    }

    /**
     * Sets hostUrl
     *
     * @param hostUrl hostUrl to set
     */
    public void setHostUrl(String hostUrl) {
        this.hostUrl = hostUrl;
    }

    /**
     * getIgnoreTrustCert
     *
     * @return ignoreTrustCert
     */
    public boolean isIgnoreTrustCert() {
        return ignoreTrustCert;
    }

    /**
     * Sets ignoreTrustCert
     *
     * @param ignoreTrustCert ignoreTrustCert to set
     */
    public void setIgnoreTrustCert(boolean ignoreTrustCert) {
        this.ignoreTrustCert = ignoreTrustCert;
    }

    /**
     * getEnableCertSecurity
     *
     * @return enableCertSecurity
     */
    public boolean isEnableCertSecurity() {
        return enableCertSecurity;
    }

    /**
     * Sets enableCertSecurity
     *
     * @param enableCertSecurity enableCertSecurity to set
     */
    public void setEnableCertSecurity(boolean enableCertSecurity) {
        this.enableCertSecurity = enableCertSecurity;
    }

    /**
     * getKeyStore
     *
     * @return keyStore
     */
    public String getKeyStore() {
        return keyStore;
    }

    /**
     * Sets keyStore
     *
     * @param keyStore keyStore to set
     */
    public void setKeyStore(String keyStore) {
        this.keyStore = keyStore;
    }

    /**
     * getKeyStorePwd
     *
     * @return keyStorePwd
     */
    public String getKeyStorePwd() {
        return keyStorePwd;
    }

    /**
     * Sets keyStorePwd
     *
     * @param keyStorePwd keyStorePwd to set
     */
    public void setKeyStorePwd(String keyStorePwd) {
        this.keyStorePwd = keyStorePwd;
    }

    /**
     * getTrustStore
     *
     * @return trustStore
     */
    public String getTrustStore() {
        return trustStore;
    }

    /**
     * Sets trustStore
     *
     * @param trustStore trustStore to set
     */
    public void setTrustStore(String trustStore) {
        this.trustStore = trustStore;
    }

    /**
     * getTrustStorePwd
     *
     * @return trustStorePwd
     */
    public String getTrustStorePwd() {
        return trustStorePwd;
    }

    /**
     * Sets trustStorePwd
     *
     * @param trustStorePwd trustStorePwd to set
     */
    public void setTrustStorePwd(String trustStorePwd) {
        this.trustStorePwd = trustStorePwd;
    }

    /**
     * getProxy
     *
     * @return proxy
     */
    public Proxy getProxy() {
        return proxy;
    }

    /**
     * Sets proxy
     *
     * @param proxy proxy to set
     */
    public void setProxy(Proxy proxy) {
        this.proxy = proxy;
    }

    /**
     * getBaseUrl
     *
     * @return baseUrl
     */
    public String getBaseUrl() {
        return baseUrl;
    }

    /**
     * Sets baseUrl
     *
     * @param baseUrl baseUrl to set
     */
    public void setBaseUrl(String baseUrl) {
        this.baseUrl = baseUrl;
    }

    /**
     * getTokenUri
     *
     * @return tokenUri
     */
    public String getTokenUri() {
        return tokenUri;
    }

    /**
     * Sets tokenUri
     *
     * @param tokenUri tokenUri to set
     */
    public void setTokenUri(String tokenUri) {
        this.tokenUri = tokenUri;
    }

    /**
     * getFormDataTemplate
     *
     * @return formDataTemplate
     */
    public String getFormDataTemplate() {
        return formDataTemplate;
    }

    /**
     * Sets formDataTemplate
     *
     * @param formDataTemplate formDataTemplate to set
     */
    public void setFormDataTemplate(String formDataTemplate) {
        this.formDataTemplate = formDataTemplate;
    }


    /**
     * getLocalVarQueryParams
     *
     * @return localVarQueryParams
     */
    public List<Pair> getLocalVarQueryParams() {
        return localVarQueryParams;
    }

    /**
     * Sets localVarQueryParams
     *
     * @param localVarQueryParams localVarQueryParams to set
     */
    public void setLocalVarQueryParams(List<Pair> localVarQueryParams) {
        this.localVarQueryParams = localVarQueryParams;
    }

    /**
     * getClientAuthorization
     *
     * @return clientAuthorization
     */
    public ClientCredential getClientAuthorization() {
        return clientAuthorization;
    }

    /**
     * Sets clientAuthorization
     *
     * @param clientAuthorization clientAuthorization to set
     */
    public void setClientAuthorization(ClientCredential clientAuthorization) {
        this.clientAuthorization = clientAuthorization;
    }

    /**
     * getFormData
     *
     * @return formData
     */
    public List<String> getFormData() {
        return formData;
    }

    /**
     * Sets formData
     *
     * @param formData formData to set
     */
    public void setFormData(List<String> formData) {
        this.formData = formData;
    }

    /**
     * getThresholdPrcnt
     *
     * @return thresholdPrcnt
     */
    public int getThresholdPrcnt() {
        return thresholdPrcnt;
    }

    /**
     * Sets thresholdPrcnt
     *
     * @param thresholdPrcnt thresholdPrcnt to set
     */
    public void setThresholdPrcnt(int thresholdPrcnt) {
        this.thresholdPrcnt = thresholdPrcnt;
    }
}
