How to use following in static method keeping threadsafe intact
public class CardTsysValidator implements TSYSConstants {
    private static final Messages messages = Messages.getMessages(CardTsysValidator.class);
    private static final Log log = LogFactory.getLog(CardTsysValidator.class);

    private final Map<String, Object> fields;
    private Pattern addressPattern;
    public CardTsysValidator() {
        this.fields = new HashMap<>();
        this.addressPattern =Pattern.compile(ADDRESS_TYPE_REGX);
    }

    /**
     * Collects fields and values to validate missing fields
     * @param fieldName
     * @param value
     */
    public void validateMissingFields(String fieldName, Object value) {
        this.fields.put(fieldName, value);
    }

    /**
     * Collects fields and values to validate invalid fields
     * @param fieldName
     * @param value
     */
    public void validateInvalidFields(String fieldName, String value) {
        this.fields.put("INVALID-"+fieldName, value);
    }

    private List<String> getMissingFields(Map<String, Object> fieldsAndValues) {
        List<String> missingFields = new ArrayList<>();
        for (Map.Entry<String, Object> fieldValue : fieldsAndValues.entrySet()) {
            Object object = fieldValue.getValue();
            if (object == null || (object instanceof String && ((String) object).isEmpty())) {
                missingFields.add(fieldValue.getKey());
            }
        }
        return missingFields;
    }
    private List<String> getInvalidFields(Map<String, Object> fieldsAndValues) {
        List<String> missingFields = new ArrayList<>();
        for (Map.Entry<String, Object> fieldValue : fieldsAndValues.entrySet()) {
            Object object = fieldValue.getValue();
            if (object != null && (object instanceof String && !((String) object).isEmpty())) {
                String invalidFieldName = fieldValue.getKey();
                if(invalidFieldName.startsWith("INVALID-")){
                    String actualFieldName = StringUtils.substringAfter(invalidFieldName, "INVALID-");
                    missingFields.add(actualFieldName+"["+object+"]");
                }
            }
        }
        return missingFields;
    }

    public void validateAddressTypes(String addressType){
        if(addressType != null && !isAddressMatch(addressType)) {
            validateInvalidFields(CARD_POSTAL_ADDR_TYPE, addressType);
        }
    }

    private boolean isAddressMatch(String addressType) {
        Matcher matcher = addressPattern.matcher(addressType);
        return matcher.matches();
    }

    public void validateCountryAndAddressType(String addressType, String countryCode){
        isAddressMatch(addressType);
    }

    public void doValidate() throws ServiceException {
        List<String> missingFields = getMissingFields(fields);
        List<String> invalidFields = getInvalidFields(fields);
        List<String> errorMessageList = new ArrayList<>();
        if (!missingFields.isEmpty()) {
            boolean firstInvalidField = true;
            StringBuilder missingFieldBuilder = new StringBuilder();
            for (String field : missingFields) {
                if(firstInvalidField){
                    firstInvalidField = false;
                } else {
                    missingFieldBuilder.append(COMMA);
                }
                missingFieldBuilder.append(field);
            }
            errorMessageList.add(messages.getString(TSYS_400, missingFieldBuilder.toString()));
        }
        if(!invalidFields.isEmpty()) {
            StringBuilder invalidFieldBuilder = new StringBuilder();
            boolean firstInvalidField = true;
            for(String field :invalidFields) {
                if(firstInvalidField) {
                    firstInvalidField = false;
                } else {
                    invalidFieldBuilder.append(COMMA);
                }
                invalidFieldBuilder.append(field);
            }
            errorMessageList.add(messages.getString(TSYS_401, invalidFieldBuilder.toString()));
        }
        if(!errorMessageList.isEmpty()){
            boolean firstInvalidField = true;
            StringBuilder errorMessages = new StringBuilder();
            for(String error:errorMessageList){
                if(firstInvalidField) {
                    firstInvalidField = false;
                } else {
                    errorMessages.append(NEWLINE);
                }
                errorMessages.append(error);
            }
            log.error(TSYS, TSYSConstants.VALIDATE, errorMessages.toString());
            throw new ServiceException(errorMessages.toString(), HTTP_400);
        }
    }
}
